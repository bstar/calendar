import { Meta, Story, Canvas } from '@storybook/addon-docs';
import CLACalendar from './CLACalendar';
import { createStoryParameters } from './utils/story-helpers';
import {
  NullSettingsStory,
  UndefinedSettingsStory,
  EmptySettingsStory,
  InvalidNumbersStory,
  NullArraysStory,
  EmptyLayersStory,
  MixedNullPropertiesStory,
  PartialConfigStory,
  MinimalSetupStory,
  InvalidDateRangeStory,
  MalformedLayersStory,
  ExtremeValuesStory,
  InvalidRestrictionsStory,
  ConflictingRestrictionsStory,
  InvalidEventDataStory,
} from './stories/ConfigurationEdgeCasesStories';
import {
  nullSettingsCode,
  undefinedSettingsCode,
  emptySettingsCode,
  invalidNumbersCode,
  nullArraysCode,
  emptyLayersCode,
  mixedNullPropertiesCode,
  partialConfigCode,
  minimalSetupCode,
  invalidDateRangeCode,
  malformedLayersCode,
  extremeValuesCode,
  invalidRestrictionsCode,
  conflictingRestrictionsCode,
  invalidEventDataCode,
} from './stories/configuration-edge-cases-code-examples';

<Meta title="Calendar/Configuration Edge Cases" component={CLACalendar} />

# Configuration Edge Cases

This section demonstrates how CLACalendar handles various edge cases, invalid configurations, and null/undefined values gracefully. The component is designed to be resilient and provide sensible defaults when given incomplete or invalid data.

## Overview

The calendar component includes robust error handling for:
- **Null/Undefined Values** - Missing or undefined configuration
- **Invalid Data Types** - Wrong types for properties
- **Out-of-Bounds Values** - Numbers outside valid ranges
- **Malformed Objects** - Incomplete or invalid object structures
- **Conflicting Settings** - Mutually exclusive configurations

## Null and Undefined Handling

### Null Settings

The calendar handles completely null settings by using all default values:

<Canvas withSource="open">
  <Story name="Null Settings Example" parameters={createStoryParameters(nullSettingsCode)}>
    {() => <NullSettingsStory />}
  </Story>
</Canvas>

### Undefined Settings

Similarly, undefined settings are replaced with defaults:

<Canvas withSource="open">
  <Story name="Undefined Settings Example" parameters={createStoryParameters(undefinedSettingsCode)}>
    {() => <UndefinedSettingsStory />}
  </Story>
</Canvas>

### Empty Settings Object

An empty settings object results in all defaults being applied:

<Canvas withSource="open">
  <Story name="Empty Settings Example" parameters={createStoryParameters(emptySettingsCode)}>
    {() => <EmptySettingsStory />}
  </Story>
</Canvas>

## Invalid Numeric Values

### Out of Bounds Numbers

The calendar sanitizes invalid numeric values to safe defaults:

<Canvas withSource="open">
  <Story name="Invalid Numbers Example" parameters={createStoryParameters(invalidNumbersCode)}>
    {() => <InvalidNumbersStory />}
  </Story>
</Canvas>

**What happens:**
- Negative `visibleMonths` → Defaults to 1
- `monthWidth` too small → Defaults to minimum width
- Values above maximum → Capped at safe maximum

### Extreme Values

Testing with extreme numeric values:

<Canvas withSource="open">
  <Story name="Extreme Values Example" parameters={createStoryParameters(extremeValuesCode)}>
    {() => <ExtremeValuesStory />}
  </Story>
</Canvas>

**Sanitization:**
- `visibleMonths: 999` → Capped at 6
- `monthWidth: -100` → Defaults to 300
- Invalid colors → Fallback to defaults

## Array Handling

### Null Arrays

Null arrays are converted to default arrays:

<Canvas withSource="open">
  <Story name="Null Arrays Example" parameters={createStoryParameters(nullArraysCode)}>
    {() => <NullArraysStory />}
  </Story>
</Canvas>

### Empty Layers Array

Empty layers array triggers default layer creation:

<Canvas withSource="open">
  <Story name="Empty Layers Example" parameters={createStoryParameters(emptyLayersCode)}>
    {() => <EmptyLayersStory />}
  </Story>
</Canvas>

## Mixed Invalid Properties

### Mixed Null/Undefined

The calendar filters out null and undefined properties:

<Canvas withSource="open">
  <Story name="Mixed Null Properties Example" parameters={createStoryParameters(mixedNullPropertiesCode)}>
    {() => <MixedNullPropertiesStory />}
  </Story>
</Canvas>

### Partial Configuration

Partial configs with some invalid values:

<Canvas withSource="open">
  <Story name="Partial Config Example" parameters={createStoryParameters(partialConfigCode)}>
    {() => <PartialConfigStory />}
  </Story>
</Canvas>

## Date Handling

### Invalid Date Range

When end date is before start date:

<Canvas withSource="open">
  <Story name="Invalid Date Range Example" parameters={createStoryParameters(invalidDateRangeCode)}>
    {() => <InvalidDateRangeStory />}
  </Story>
</Canvas>

**Behavior:**
- Invalid ranges are corrected automatically
- End date adjusted to match or exceed start date
- User notified through UI feedback

## Complex Data Structures

### Malformed Layers

Handling layers array with invalid entries:

<Canvas withSource="open">
  <Story name="Malformed Layers Example" parameters={createStoryParameters(malformedLayersCode)}>
    {() => <MalformedLayersStory />}
  </Story>
</Canvas>

**Filtering behavior:**
- Null/undefined entries removed
- Invalid layer objects skipped
- Valid layers preserved

### Invalid Event Data

Events and backgrounds with invalid data:

<Canvas withSource="open">
  <Story name="Invalid Event Data Example" parameters={createStoryParameters(invalidEventDataCode)}>
    {() => <InvalidEventDataStory />}
  </Story>
</Canvas>

**Event sanitization:**
- Invalid dates skipped
- Missing required fields ignored
- Null values filtered out
- Invalid colors use defaults

## Restriction Edge Cases

### Invalid Restrictions

Testing invalid restriction configurations:

<Canvas withSource="open">
  <Story name="Invalid Restrictions Example" parameters={createStoryParameters(invalidRestrictionsCode)}>
    {() => <InvalidRestrictionsStory />}
  </Story>
</Canvas>

### Conflicting Restrictions

When restrictions contradict each other:

<Canvas withSource="open">
  <Story name="Conflicting Restrictions Example" parameters={createStoryParameters(conflictingRestrictionsCode)}>
    {() => <ConflictingRestrictionsStory />}
  </Story>
</Canvas>

**Conflict resolution:**
- More restrictive rules take precedence
- Allowed ranges evaluated first
- Clear user feedback provided

## Minimal Setup

### Essential Configuration Only

A minimal working configuration:

<Canvas withSource="open">
  <Story name="Minimal Setup Example" parameters={createStoryParameters(minimalSetupCode)}>
    {() => <MinimalSetupStory />}
  </Story>
</Canvas>

## Error Handling Best Practices

### 1. Defensive Defaults
```tsx
const safeSettings = {
  ...getDefaultSettings(),
  ...userSettings,
  // Ensure critical values
  visibleMonths: Math.max(1, Math.min(6, userSettings?.visibleMonths || 2)),
  monthWidth: Math.max(200, userSettings?.monthWidth || 300),
};
```

### 2. Type Guards
```tsx
// Check if layers array is valid
if (Array.isArray(settings.layers)) {
  const validLayers = settings.layers.filter(
    layer => layer && typeof layer.name === 'string'
  );
}
```

### 3. Null Coalescing
```tsx
const displayMode = settings?.displayMode ?? 'popup';
const colors = settings?.colors ?? DEFAULT_COLORS;
```

### 4. Validation Functions
```tsx
function validateDateRange(range) {
  if (!range?.start || !range?.end) return null;
  const start = new Date(range.start);
  const end = new Date(range.end);
  if (isNaN(start) || isNaN(end)) return null;
  if (end < start) return { start: range.start, end: range.start };
  return range;
}
```

## Component Resilience Features

### Automatic Corrections
- **Numeric bounds**: Values clamped to valid ranges
- **Date ordering**: End dates adjusted if before start
- **Missing data**: Default values provided
- **Type mismatches**: Converted or ignored

### Silent Failures
- **Invalid layers**: Skipped without breaking
- **Bad events**: Filtered out silently
- **Null properties**: Replaced with defaults
- **Malformed data**: Ignored gracefully

### User Feedback
- **Console warnings**: For development debugging
- **UI indicators**: Visual feedback for issues
- **Fallback content**: Always shows something useful
- **Error boundaries**: Prevents complete failure

## Testing Edge Cases

When implementing calendar features, test these scenarios:

1. **Null/Undefined**: Pass `null`, `undefined`, and `{}`
2. **Wrong Types**: Strings where numbers expected, etc.
3. **Empty Arrays**: `[]` for layers, restrictions
4. **Invalid Dates**: Malformed date strings, invalid formats
5. **Extreme Values**: Very large/small numbers
6. **Missing Required**: Omit required properties
7. **Circular References**: Objects referencing themselves
8. **Mixed Valid/Invalid**: Arrays with some good, some bad data

## Summary

The CLACalendar component is designed to be highly resilient:
- **Never crashes** from bad input
- **Provides sensible defaults** for all settings
- **Filters invalid data** automatically
- **Gives user feedback** when appropriate
- **Maintains functionality** even with poor configuration

This robust error handling ensures a reliable user experience regardless of the configuration provided.